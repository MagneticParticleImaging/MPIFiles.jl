var documenterSearchIndex = {"docs":
[{"location":"positions.html#Positions","page":"Positions","title":"Positions","text":"MPIFiles contains several types describing point sets. ","category":"section"},{"location":"transferfunction.html#Transfer-functions","page":"Transfer Functions","title":"Transfer functions","text":"MPIFiles defines the type TransferFunction which represents the system-properties of a linear time-invariant system in frequency space (see also). In the context of MPIFiles this usually includes the properties of the receive chain of an MPI system, but can also hold information about other parts of the signal chain. ","category":"section"},{"location":"transferfunction.html#Basic-construction-and-data-access","page":"Transfer Functions","title":"Basic construction and data access","text":"The TransferFunction object is constructed from samples in frequency space and offers two ways to access the underlying data. The first uses indexing to directly access the underlying data:\n\n    f = collect(range(0,1e6,step=1e3));\n    # TransferFunction of a simple lowpass filter\n    tf = TransferFunction(f, 1 ./ (1 .+ im*f/1e4 )) \n    tf[1] # Value of tf at first frequency sample (f = 0 Hz)\n\nThe second method has to be called on the object itself and uses linear interpolation to access the tf at any frequency:\n\n    tf(0) # Value of tf at f = 0 Hz\n    tf(1e4) # Value of tf at f = 10000 Hz\n\nA TransferFunction can have multiple channels, which adds a second index to both data access functions. Directly accessing multiple channels is also possible. The complex array used to construct the TransferFunction needs to have the shape [number of frequency samples, channels].\n\ntf = TransferFunction(f, [1 ./(1 .+im*f/1e4) 1 ./(1 .+im*f/1e3)])\ntf[11,1]\ntf[11,2]\ntf(1e4,1)\ntf(1e4,2)\ntf(1e4, [1,2])\ntf(1e4,:)","category":"section"},{"location":"transferfunction.html#Units","page":"Transfer Functions","title":"Units","text":"To attach units to the TransferFunction the keyword-parameter units can to be used to give a Unitful unit to every channel of the tf. Alternatively data can just be a Unitful.Quantity. Then units is ignored.\n\nThis can be useful if the transfer function is not dimensionless but relates two physical quantities, e.g. voltage and current in the form of an impedance. All interpolated accesses to tf data then return a Unitful.Quantity.\n\nR = 1; # Ohm\nL = 10e-6; # Henry\nRL = TransferFunction(f, R .+ im*2pi*f*L, units=[\"V/A\"])\nRL([0,100e3])\n\nf_unitful = collect(range(0u\"Hz\",1u\"MHz\",step=1u\"kHz\"));\nR = 1u\"Ω\";\nL = 10u\"µH\";\nRL = TransferFunction(f_unitful, R .+ im*2pi*f_unitful*L .|> u\"V/A\")\nRL([0,100e3])","category":"section"},{"location":"transferfunction.html#Saving-and-loading","page":"Transfer Functions","title":"Saving and loading","text":"A TransferFunction object can be saved to and loaded from a .h5 file.","category":"section"},{"location":"transferfunction.html#Constructors","page":"Transfer Functions","title":"Constructors","text":"The TransferFunction constructor can take either a complex data array or two arrays representing the amplitude and phase of the transfer function. Unitful conversion is automatically done for all parameters.\n\nIt is also possible to construct a TransferFunction from the transfer function data included in an MPIFile.","category":"section"},{"location":"transferfunction.html#Other-interesting-functions","page":"Transfer Functions","title":"Other interesting functions","text":"","category":"section"},{"location":"transferfunction.html#FileIO.save-Tuple{String, TransferFunction}","page":"Transfer Functions","title":"FileIO.save","text":"save(filename::String, tf::TransferFunction)\n\n\nSave tf as a h5 file to filename\n\n\n\n\n\n","category":"method"},{"location":"transferfunction.html#MPIFiles.TransferFunction-Tuple{String}","page":"Transfer Functions","title":"MPIFiles.TransferFunction","text":"TransferFunction(filename::String; kargs...) -> Any\n\n\nCreate a TransferFunction from a data file at filename.\n\nThe file can be either a h5-File created with this package or a file that is written by a VNA. Keyword arguments will be passed to load_tf_fromVNA \n\n\n\n\n\n","category":"method"},{"location":"transferfunction.html#MPIFiles.TransferFunction","page":"Transfer Functions","title":"MPIFiles.TransferFunction","text":"mutable struct TransferFunction\n\nfreq::Vector{Float64}\ndata::Matrix{ComplexF64}\ninterpolator::Vector{Interpolations.AbstractInterpolation}\ninductionFactor::Vector{Float64}\nunits::Vector{Unitful.FreeUnits}\n\nTransferFunction(freq::Vector, data::Array, [phasedata]; [inductionFactor], [units])\n\nCreate a TransferFunction from a data array data at frequencies freq. freq is given in Hz or should have a Unitful frequency unit attached data should have the shape [frequencies, channels]. data can be either complex or real, if data is real a second array phasedata can be passed representing the phase in radians. Both the amplitude and the phase can have Unitful units.\n\nOptional Keyword-Arguments:\n\ninductionFactor::Vector{<:Real}: induction factor for each channel\nunits::Vector: units for each channel, can be either Unitful.FreeUnits or a string that can be parsed as a Unitful unit. Instead of using this keyword, data can also have Unitful units attached, then the units keyword-argument is ignored.\n\n\n\n\n\n","category":"type"},{"location":"transferfunction.html#MPIFiles.TransferFunction-Tuple{MPIFile}","page":"Transfer Functions","title":"MPIFiles.TransferFunction","text":"TransferFunction(file::MPIFile) -> Any\n\n\nCreate a TransferFunction from the tf data saved in a MPIFile (see rxTransferFunction)\n\n\n\n\n\n","category":"method"},{"location":"transferfunction.html#MPIFiles.combine-Tuple{TransferFunction, TransferFunction}","page":"Transfer Functions","title":"MPIFiles.combine","text":"combine(\n    tf1::TransferFunction,\n    tf2::TransferFunction;\n    interpolate\n) -> Any\n\n\nCombine two TransferFunctions along their channel dimension. If interpolate=false, will only work if the frequency samples are identical.\n\n\n\n\n\n","category":"method"},{"location":"transferfunction.html#MPIFiles.load_tf_fromVNA","page":"Transfer Functions","title":"MPIFiles.load_tf_fromVNA","text":"load_tf_fromVNA(\n    filename::String;\n    kwargs...\n) -> TransferFunction\n\n\nLoad data receive calibration from file recorded with the VNA. Data will be processed by processRxTransferFunction, see there for keyword arguments\n\n\n\n\n\n","category":"function"},{"location":"transferfunction.html#MPIFiles.processRxTransferFunction","page":"Transfer Functions","title":"MPIFiles.processRxTransferFunction","text":"processRxTransferFunction(\n    freq,\n    compdata;\n    frequencyWeighting,\n    R,\n    N,\n    A,\n    r,\n    d\n) -> Any\n\n\nProcess the data from a receive calibration measurement using a calibration coil into a TransferFunction\n\nKeyword parameters:\n\nfrequencyWeighting: if true corrects for the frequency term in the TF, which results in a TF that does not integrate on application, but instead shows derivative of magnetic moment\nR: value of the resistance of the calibration coil in Ω\nN: number of turns of the calibration coil\nA, r, d: Area in m² or radius/diameter in m of the calibration coil, define only one\n\n\n\n\n\n","category":"function"},{"location":"frequencyFilter.html#Frequency-Filter","page":"Frequency Filter","title":"Frequency Filter","text":"A frequency filter can be calculated using the function\n\nfunction filterFrequencies(f::MPIFile;\n                           SNRThresh=-1,\n                           minFreq=0, maxFreq=rxBandwidth(f),\n                           recChannels=1:rxNumChannels(f),\n                           sortBySNR=false,\n                           numUsedFreqs=-1,\n                           stepsize=1,\n                           maxMixingOrder=-1,\n                           sortByMixFactors=false)\n\nUsually one will apply an SNR threshold SNRThresh > 1.5 and a minFreq that is larger than the excitation frequencies. The frequencies are specified in Hz. Also useful is the opportunity to select specific receive channels by specifying recChannels.\n\nThe return value of filterFrequencies is of type Vector{Int64} and can be directly passed to getMeasurements, getMeasurementsFD, and getSystemMatrix.","category":"section"},{"location":"conversion.html#Conversion","page":"Conversion","title":"Conversion","text":"With the support for reading different file formats and the ability to store data in the MDF, it is also possible to convert files into MDF. This can be done by calling\n\nsaveasMDF(filenameOut, filenameIn)\n\nThe second argument can alternatively also be an MPIFile handle.\n\nAlternatively, there is also a more low level interface which gives the user the control to change parameters before storing. This look like this\n\nparams = loadDataset(f)\n# do something with params\nsaveasMDF(filenameOut, params)\n\nHere, f is an MPIFile handle and the command loadDataset loads the entire dataset including all parameters into a Julia Dict, which can be modified by the user. After modification one can store the data by passing the Dict as the second argument to the saveasMDF function.\n\nnote: Note\nThe parameters in the Dict returned by loadDataset have the same keys as the corresponding accessor functions listed in the Low Level Interface.","category":"section"},{"location":"systemmatrix.html#System-Matrices","page":"System Matrices","title":"System Matrices","text":"For loading the system matrix, one could in principle again call measData but there is again a high level function for this job. Since system functions can be very large it is crucial to load only the subset of frequencies that are used during reconstruction The high level system matrix loading function is called getSystemMatrix and has the following interface:\n\nfunction getSystemMatrix(f::MPIFile,\n                         frequencies=1:rxNumFrequencies(f)*rxNumChannels(f);\n                         bgCorrection=false,\n                         loadasreal=false,\n                         kargs...)\n\nloadasreal can again be used when using a solver requiring real numbers. The most important parameter is frequencies, which defaults to all possible frequencies over all receive channels. In practice, one will determine the frequencies using the the Frequency Filter functionality. The parameter bgCorrection controls if a  background correction is applied while loading the system matrix. The return value of getSystemMatrix is a matrix of type ComplexF32 or Float32 with the rows encoding the spatial dimension and the columns encoding the dimensions frequency, receive channels, and patches.","category":"section"},{"location":"reconstruction.html#Reconstruction-Results","page":"Reconstruction Results","title":"Reconstruction Results","text":"MDF files can also contain reconstruction results instead of measurement data. The low level results can be retrieved using the Low Level Interface\n\nfunction recoData(f::MPIFile)\nfunction recoFov(f::MPIFile)\nfunction recoFovCenter(f::MPIFile)\nfunction recoSize(f::MPIFile)\nfunction recoOrder(f::MPIFile)\nfunction recoPositions(f::MPIFile)\n\nInstead, one can also combine these data into an ImageMetadata object from the Images.jl package by calling the functions\n\nfunction loadRecoData(filename::AbstractString)\n\nThe ImageMetadata object does also pull all relevant metadata from an MDF such that the file can be also be stored using\n\nfunction saveRecoData(filename, image::ImageMeta)\n\nThese two functions are especially relevant when using the package   MPIReco.jl","category":"section"},{"location":"lowlevel.html#Low-Level-Interface","page":"Low Level Interface","title":"Low Level Interface","text":"The low level interface of MPIFiles.jl consists of a collection of methods that need to be implemented for each file format. It consists of the following methods\n\n# general\nversion, uuid\n\n# study parameters\nstudyName, studyNumber, studyUuid, studyDescription\n\n# experiment parameters\nexperimentName, experimentNumber, experimentUuid, experimentDescription,\nexperimentSubject, experimentIsSimulation, experimentIsCalibration,\nexperimentHasMeasurement, experimentHasReconstruction\n\n# tracer parameters\ntracerName, tracerBatch, tracerVolume, tracerConcentration, tracerSolute,\ntracerInjectionTime, tracerVendor\n\n# scanner parameters\nscannerFacility, scannerOperator, scannerManufacturer, scannerName, scannerTopology\n\n# acquisition parameters\nacqStartTime, acqNumFrames, acqNumAverages, acqGradient, acqOffsetField,\nacqNumPeriodsPerFrame\n\n# drive-field parameters\ndfNumChannels, dfStrength, dfPhase, dfBaseFrequency, dfCustomWaveform, dfDivider,\ndfWaveform, dfCycle\n\n# receiver parameters\nrxNumChannels, rxBandwidth, rxNumSamplingPoints, rxTransferFunction, rxUnit,\nrxDataConversionFactor, rxInductionFactor\n\n# measurements\nmeasData, measDataTDPeriods, measIsFourierTransformed, measIsTFCorrected,\nmeasIsBGCorrected, measIsFastFrameAxis, measIsFramePermutation, measIsFrequencySelection,\nmeasIsBGFrame, measIsSpectralLeakageCorrected, measFramePermutation\n\n# calibrations\ncalibSNR, calibFov, calibFovCenter, calibSize, calibOrder, calibPositions,\ncalibOffsetFields, calibDeltaSampleSize, calibMethod, calibIsMeanderingGrid\n\n# reconstruction results\nrecoData, recoFov, recoFovCenter, recoSize, recoOrder, recoPositions\n\n# additional functions that should be implemented by an MPIFile\nfilepath, systemMatrixWithBG, systemMatrix, selectedChannels\n\nThe interface is structured in a similar way as the parameters within the MDF. Basically, there is a direct mapping between the MDF parameters and the MPIFiles interface. For instance the parameter acqNumAvarages maps to the MDF parameter /acquisition/numAverages. Also the dimensionality of the parameters described in the MDF is preserved. Thus, the MDF specification can be used as a documentation of the low level interface of MPIFiles.","category":"section"},{"location":"lowlevel.html#In-memory-MDF","page":"Low Level Interface","title":"In-memory MDF","text":"Since during data acquisition it is not advisable to write the data directly to an MDF file, there is also an in-memory representation. It can be created either empty by mdf = MDFv2InMemory() or with default values set by mdf = defaultMDFv2InMemory(). The same interface as described above applies to the in-memory version. When writing it to disk using saveasMDF(\"your/file/path/file.mdf\", mdf) it is checked for consistency. If this check should fail with an error, use saveasMDF(\"your/file/path/file.mdf\", mdf, failOnInconsistent=true). The default is to not fail in order to not lose measurement data in case of an error.\n\nnote: Note\nNote that the dimensions in the MDF documentation are flipped compared to the dimensions in Julia. This is because Julia stores the data in column major order, while HDF5 considers row major order","category":"section"},{"location":"index.html#MPIFiles.jl","page":"Home","title":"MPIFiles.jl","text":"Magnetic Particle Imaging Files","category":"section"},{"location":"index.html#Introduction","page":"Home","title":"Introduction","text":"MPIFiles.jl is a Julia package for handling files that are related to the tomographic imaging method magnetic particle imaging. It supports different file formats:\n\nBrukerfiles, i.e. files stored using the preclinical MPI scanner from Bruker\nMagnetic Particle Imaging Data Format (MDF) files\nIMT files, i.e. files created at the Institute of Medical Engineering in Lübeck\n\nFor all of these formats there is full support for reading the files. Write support is currently only available for MDF files. All files can be converted to MDF files using this capability.\n\nMPIFiles.jl provides a generic interface for different MPI files. In turn it is possible to write generic algorithms that work for all supported file formats.\n\nMPI files can be divided into three different categories\n\nMeasurements\nSystem Matrices\nReconstruction Results\n\nEach of these file types is supported and discussed in the referenced pages.","category":"section"},{"location":"index.html#Installation","page":"Home","title":"Installation","text":"Start julia and open the package mode by entering ]. Then enter\n\nadd MPIFiles\n\nThis will install the packages MPIFiles.jl and all its dependencies.","category":"section"},{"location":"index.html#License-/-Terms-of-Usage","page":"Home","title":"License / Terms of Usage","text":"The source code of this project is licensed under the MIT license. This implies that you are free to use, share, and adapt it. However, please give appropriate credit by citing the project.","category":"section"},{"location":"index.html#Community-Guidelines","page":"Home","title":"Community Guidelines","text":"If you have problems using the software, find bugs, or have feature requests please use the issue tracker to contact us. For general questions we prefer that you contact the current maintainer directly by email.\n\nWe welcome community contributions to MPIFiles.jl. Simply create a pull request with your proposed changes.","category":"section"},{"location":"index.html#Contributors","page":"Home","title":"Contributors","text":"Tobias Knopp (maintainer)\nMartin Möddel\nPatryk Szwargulski\nFlorian Griese\nFranziska Werner\nNadine Gdaniec\nMarija Boberg\nJonas Schumacher","category":"section"},{"location":"gettingStarted.html#Getting-Started","page":"Getting Started","title":"Getting Started","text":"In order to get started with MPIFiles we first need some example datasets. These can be obtained by calling\n\ndownload(\"https://media.tuhh.de/ibi/mdfv2/measurement_V2.mdf\", \"measurements.mdf\")\ndownload(\"https://media.tuhh.de/ibi/mdfv2/systemMatrix_V2.mdf\", \"systemMatrix.mdf\")\n\nwhich will download an MPI system matrix and an MPI measurement dataset into the current directory.\n\nAn MPI data file consists of a collection of parameters that can be divided into metadata and measurement data. We can open the downloaded MPI measurement data by calling\n\nf = MPIFile(\"measurements.mdf\")\n\nf can be considered to be a handle to the file. The file will be automatically  closed when f is garbage collected. The philosophy of MPIFiles.jl is that the content of the file is only loaded on demand. Hence, opening an MPI file is a cheap operation. This design allows it, to handle system matrices, which are larger than the main memory of the computer.\n\nUsing the file handle it is possible now to read out different metadata. For instance, we can determine the number of frames measured:\n\nprintln( acqNumFrames(f) )\n500\n\nOr we can access the drive field strength\n\nprintln( dfStrength(f) )\n1×3×1 Array{Float64,3}:\n[:, :, 1] =\n 0.014  0.014  0.0\n\nNow let us load some measurement data. This can be done by calling\n\nu = getMeasurementsFD(f, frames=1:100, numAverages=100)\n\nThen we can display the data using the PyPlot package\n\nusing PyPlot\nfigure(6, figsize=(6,4))\nsemilogy(abs.(u[1:400,1,1,1]))\n\n(Image: Spectrum)\n\nThis shows a typical spectrum for a 2D Lissajous sampling pattern. The getMeasurementsFD is a high level interface for loading MPI data, which has several parameters that allow to customize the loading process. Details on loading measurement data are outlined in Measurements.\n\nIn the following we will first discuss the low level interface.","category":"section"},{"location":"measurements.html#Measurements","page":"Measurements","title":"Measurements","text":"The low level interface allows to load measured MPI data via the measData function. The returned data is exactly how it is stored on disc. This has the disadvantage that the user needs to handle different sorts of data that can be stored in the measData field. To cope with this issue, the MDF also has a high level interface for loading measurement data. The first is the function\n\nfunction getMeasurements(f::MPIFile, neglectBGFrames=true;\n                frames=neglectBGFrames ? (1:acqNumFGFrames(f)) : (1:acqNumFrames(f)),\n                numAverages=1,\n                bgCorrection=false,\n                interpolateBG=false,\n                tfCorrection=measIsTFCorrected(f),\n                sortFrames=false,\n                spectralLeakageCorrection=true,\n                kargs...)\n\nthat loads the MPI data in time domain. Background frames can be neglected or included, frames can be selected by specifying frames, block averaging can be applied by specifying numAverages, bgCorrection allows to apply background correction, tfCorrection allows for a correction of the transfer function, interpolateBG applies an optional interpolation in case that multiple background intervals are included in the measurement, sortFrames puts all background frames to the end of the returned data file, and spectralLeakageCorrection controls whether a spectral leakage correction is applied.\n\nThe array returned by getMeasurements is of type Float32 and has four dimensions\n\ntime dimension (over one period)\nreceive channel dimension\npatch dimension\nframe dimension\n\nInstead of loading the data in time domain, one can also load the frequency domain data by calling\n\nfunction getMeasurementsFD(f::MPIFile, neglectBGFrames=true;\n                  loadasreal=false,\n                  transposed=false,\n                  frequencies=nothing,\n                  tfCorrection=measIsTFCorrected(f),\n                  kargs...)\n\nThe function has basically the same parameters as getMeasurements but, additionally, it is possible to load the data in real form (useful when using a solver that cannot handle complex numbers), it is possible to specify the frequencies (specified by the indices) that should be loaded, and it is possible to transpose the data in a special way, where the frame dimension is changed to be the first dimension. getMeasurementsFD returns a 4D array where of type ComplexF32 with dimensions\n\nfrequency dimension\nreceive channel dimension\npatch dimension\nframe dimension","category":"section"}]
}
